pragma solidity ^0.6.7;

import "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/solc-0.6/contracts/access/Ownable.sol";

interface KeeperCompatibleInterface {
    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);
    function performUpkeep(bytes calldata performData) external;
}

interface IDcashDFP {
    function requestVolumeData() external returns (bytes32 requestId);
}

contract KeeperProxy is KeeperCompatibleInterface, Ownable {
    IDcashDFP dfp;

    /**
    * Public counter variable
    */
    uint public counter;


    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public immutable interval;
    uint public lastTimeStamp;
    bool public needsKeep;

    /**
     * KeeperRegistry contract
     */
    address public keeperNode;

    // event definition
    event UpdateKeeperNode(address payable _newNode);

    modifier onlyKeeper() {
        require(msg.sender == owner() || msg.sender == keeperNode, "Unauthorized access");
        _;
    }

    constructor(address dfpContract, address keeperContract) public {
        dfp = IDcashDFP(dfpContract);

        interval = 302400; // means 3.5 days x 24 hours x 3600 seconds
        lastTimeStamp = block.timestamp;

        counter = 0;
        needsKeep = true;
        keeperNode = keeperContract;
    }

    function disableUpkeep(bool toggle) external {
        needsKeep = toggle;
    }


    function checkUpkeep(bytes calldata checkData) external override returns (bool upkeepNeeded, bytes memory performData) {
        upkeepNeeded = needsKeep && (block.timestamp - lastTimeStamp) > interval;

        // checkData was defined when the Upkeep was registered
        performData = checkData;
    }

    function performUpkeep(bytes calldata performData) external override onlyKeeper {
        lastTimeStamp = block.timestamp;
        counter = counter + 1;

        // call DFP contract
        dfp.requestVolumeData();

        // performData is generated by the Keeper's call to `checkUpkeep` function
        performData;
    }

    function updateKeeperNode(address payable keeperContract) external onlyOwner {
        keeperNode = keeperContract;

        emit UpdateKeeperNode(keeperContract);
    }
}